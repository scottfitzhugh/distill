use anyhow::{Context, Result};
use log::debug;
use reqwest::Client;
use serde::{Deserialize, Serialize};

/// OpenRouter API client
pub struct OpenRouterClient {
	client: Client,
	api_key: String,
}

#[derive(Serialize)]
struct ChatRequest {
	model: String,
	messages: Vec<Message>,
	max_tokens: u32,
	temperature: f32,
}

#[derive(Serialize)]
struct Message {
	role: String,
	content: String,
}

#[derive(Deserialize)]
struct ChatResponse {
	choices: Vec<Choice>,
}

#[derive(Deserialize)]
struct Choice {
	message: MessageResponse,
}

#[derive(Deserialize)]
struct MessageResponse {
	content: String,
}

impl OpenRouterClient {
	/// Create a new OpenRouter client
	pub fn new(api_key: &str) -> Self {
		Self {
			client: Client::new(),
			api_key: api_key.to_string(),
		}
	}

	/// Generate a commit message based on the git diff
	pub async fn generate_commit_message(&self, diff: &str) -> Result<String> {
		let prompt = self.create_commit_prompt(diff);
		
		let request = ChatRequest {
			model: "meta-llama/llama-3.1-8b-instruct:free".to_string(),
			messages: vec![
				Message {
					role: "system".to_string(),
					content: "You are an expert software developer. Analyze the git diff and respond with ONLY a single line commit message in conventional commit format. Do not include any explanations, descriptions, or additional text. Just return the commit message itself. Format: 'type(scope): description' or 'type: description'. Use types like feat, fix, docs, style, refactor, test, etc. Keep it under 72 characters.".to_string(),
				},
				Message {
					role: "user".to_string(),
					content: prompt,
				},
			],
			max_tokens: 100,
			temperature: 0.3,
		};

		debug!("Sending request to OpenRouter API");

		let response = self.client
			.post("https://openrouter.ai/api/v1/chat/completions")
			.header("Authorization", format!("Bearer {}", self.api_key))
			.header("Content-Type", "application/json")
			.json(&request)
			.send()
			.await
			.context("Failed to send request to OpenRouter API")?;

		if !response.status().is_success() {
			let status = response.status();
			let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
			anyhow::bail!("OpenRouter API request failed with status {}: {}", status, error_text);
		}

		let chat_response: ChatResponse = response.json().await
			.context("Failed to parse response from OpenRouter API")?;

		let raw_response = chat_response
			.choices
			.first()
			.and_then(|choice| Some(choice.message.content.trim().to_string()))
			.context("No commit message generated by OpenRouter API")?;

		debug!("Raw API response: {}", raw_response);

		// Extract the actual commit message from the response
		let commit_message = self.extract_commit_message(&raw_response)?;

		debug!("Extracted commit message: {}", commit_message);

		Ok(commit_message)
	}

	/// Extract the actual commit message from the API response
	fn extract_commit_message(&self, response: &str) -> Result<String> {
		let response = response.trim();
		
		// If the response is already clean and looks like a commit message, return it
		if self.is_valid_commit_message(response) {
			return Ok(response.to_string());
		}

		// Try to find the commit message in the response
		let lines: Vec<&str> = response.lines().map(|line| line.trim()).collect();
		
		for line in &lines {
			// Skip empty lines and common prefixes
			if line.is_empty() 
				|| line.to_lowercase().starts_with("here") 
				|| line.to_lowercase().starts_with("the commit message")
				|| line.to_lowercase().starts_with("commit message:")
				|| line.to_lowercase().starts_with("suggested")
				|| line.contains("```")
				|| line.starts_with('#') {
				continue;
			}
			
			// Check if this line looks like a valid commit message
			if self.is_valid_commit_message(line) {
				return Ok(line.to_string());
			}
		}
		
		// If no valid commit message found, try to clean the first non-empty line
		for line in &lines {
			let cleaned = line
				.trim_matches('"')
				.trim_matches('\'')
				.trim_matches('`')
				.trim();
			
			if !cleaned.is_empty() && !cleaned.to_lowercase().starts_with("here") {
				return Ok(cleaned.to_string());
			}
		}
		
		// Last resort: return the whole response cleaned up
		let cleaned = response
			.trim_matches('"')
			.trim_matches('\'')
			.trim_matches('`')
			.trim();
			
		if cleaned.is_empty() {
			anyhow::bail!("Empty or invalid commit message received from API");
		}
		
		Ok(cleaned.to_string())
	}

	/// Check if a string looks like a valid commit message
	fn is_valid_commit_message(&self, message: &str) -> bool {
		let message = message.trim();
		
		// Must not be empty
		if message.is_empty() {
			return false;
		}
		
		// Should be a single line (no newlines)
		if message.contains('\n') {
			return false;
		}
		
		// Should not be too long
		if message.len() > 100 {
			return false;
		}
		
		// Should not contain common explanation phrases
		let lower = message.to_lowercase();
		if lower.contains("here is") 
			|| lower.contains("the commit message")
			|| lower.contains("suggested")
			|| lower.contains("example")
			|| lower.contains("would be") {
			return false;
		}
		
		// Basic pattern check: should contain a colon (conventional commits)
		// or at least look like a reasonable commit message
		message.contains(':') || message.len() > 10
	}

	/// Create a prompt for generating commit messages
	fn create_commit_prompt(&self, diff: &str) -> String {
		// Truncate diff if it's too long to avoid token limits
		let max_diff_length = 4000;
		let truncated_diff = if diff.len() > max_diff_length {
			format!("{}...\n(diff truncated due to length)", &diff[..max_diff_length])
		} else {
			diff.to_string()
		};

		format!(
			"Generate a concise git commit message for the following diff:\n\n```diff\n{}\n```\n\nCommit message:",
			truncated_diff
		)
	}
} 